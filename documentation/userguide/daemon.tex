\documentclass[notoc,justified]{tufte-book}    % `notoc` suppresses TL custom TOC, reverts to standard LaTeX
\usepackage{graphicx}
\hyphenation{HMMER}

\input{titlepage_daemon}                    % definitions for \maketitle 
\bibliographystyle{unsrtnat-brief}   % customized natbib unsrtnat. Abbrev 3+ authors to ``et al.'' 

\begin{document}
\setcounter{tocdepth}{2}             % 0=chapters 1=sections 2=subsections 3=subsubsections? 4=paragraphs
\input{inclusions/inclusions.def}    % snippets captured from output, by gen-inclusions.py 

\maketitle

\input{copyright}

\begin{adjustwidth}{}{-1in}          % TL \textwidth is quite narrow. Expand it manually for TOC and man pages.
\tableofcontents                     
\end{adjustwidth}


\chapter{Introduction}

The performance of HMMER's command-line tools is limited by two factors: the number of cores that are available to work on each search, and the amount of time required to read sequence or HMM databases from disk in order to search them.  When HMMER is run on small (2- or 4-core) desktop or laptop CPUs, CPU performance tends to be the limiting factor on search time (although this depends on the speed of the system's hard disk).  However, on systems with more cores, such as most servers, the time required to read databases from disk becomes a bottleneck that prevents performance from improving as processor performance increases.

To address this, HMMER provides a  daemon\sidenote{The term "daemon" here is taken from the UNIX term for an application or service that runs without being connected to a user login, which is derived from a Greek term that means roughly "spirit" or "supernatural being".}, known as {\em hmmpgmd} service that runs as a persistent service across multiple computers.  As shown in Figure \ref{fig:daemon}, one machine running the daemon is designated the master node, while the others become worker nodes.  Client systems send search requests to the master node via internet sockets.  When the master node receives a search, it distributes the work of the search across the worker nodes, merges the partial results from each worker node, and returns the search results to the client\sidenote{In the European Bioinformatics Institute (EBI) instantiation of the daemon, the client machines shown in the figure are EBI's web servers.  End users interact with the web servers, which provide a human-friendly interface for submitting searches and inspecting results.}.

\begin{figure*}
\includegraphics[width=\textwidth]{inclusions/daemon.pdf}
\caption{The HMMER Daemon}
\label{fig:daemon}
\end{figure*}

The daemon improves search performance over HMMER's command-line tools in two ways.  First, when the daemon starts up, it reads its input databases from disk once and caches them in RAM, eliminating the file read bottleneck on performance.  Second, it distributes the work of each search over many machines, each of which may contain tens of cores, significantly reducing the amount of work each core must perform to complete the search.  The combination of these two techniques can reduce the time to search large sequence databases to only a few seconds when the daemon is run on a large-enough set of computers.  

Hmmpgmd caches all of its database(s) in RAM on each of its worker nodes, in spite of the fact that each worker node only accesses part of a database on each search.  This allows hmmpgmd to tolerate worker node failures by simply changing how work is assigned to the worker nodes as the number of worker nodes changes, but causes hmmpgmd to use significantly more memory than would be strictly necessary, particularly when the daemon has many worker nodes.  To address this, HMMER now provides a "sharded" version of hmmpgmd, hmmpgmd\_shard, which distributes the sequences in a sequence database\sidenote{We do not support sharding of HMM databases because current HMM databases are so much smaller than current sequence databases that the amount of RAM they occupy has not been an issue.} round-robin across the worker nodes, so that each worker node only caches $\frac{1}{Nth}$ of each sequence database.  This allows systems with limited RAM to support much larger sequence databases, at the cost of making the daemon unable to execute searches unless all of its worker nodes are available.

Hmmpgmd was designed to be integrated with the European Bioinformatics Institute's computing and database infrastructure.  To reduce disk space, RAM, and bandwidth usage, sequence names, accession information, and descriptions are not included in its databases and are not cached in RAM.  Instead, each sequence or HMM is assigned an ID number based on its position in the database file, and hmmpgmd reports that ID number when a hit occurs.  EBI's web servers then look that ID number up in their own databases to retrieve the sequence/HMM's name, description, etc., and combine that with the alignment information the daemon returns when displaying search results to users.

This manual outlines hmmpgmd's usage and interface to client applications, and assumes that the reader is familiar with the concepts covered in the main \underline{HMMER User's Guide}.  It is intended for individuals who are interested in either running an hmmpgmd server of their own or in writing clients that communicate with an existing hmmpgmd server.   Biologists who wish to use an hmmpgmd server in their research without the complexity of configuring one themselves should consider using the European Bioinformatics Institute's HMMER server {\tt www.ebi.ac.uk/Tools/hmmer/}, which provides a web interface to hmmpgmd servers that load a number of common genetic databases.
 

\chapter{Usage}
To perform searches using hmmpgmd, a user must first start a daemon on one or more machines.  At least two hmmpgmd processes, one master and one worker, must be started, although these processes may be run on the same computer if only one machine is available\sidenote{When running hmmpgmd on a single machine, be aware that the master and worker processes will load the database(s) into RAM independently, so the memory required will be approximately double what is required when running the worker and master processes on separate machines.  Hmmpmd\_shard greatly reduces the amount of memory used by the master node, so using it with only one shard may be a better choice for searching sequence databases on a single machine.}.  Once the daemon is running, users can submit searches via a client program such as the hmmc2 example client HMMER provides.

\section{Running Hmmpgmd}
To start a daemon process (either master or worker), execute the "hmmpgmd" command.  Hmmpgmd requires that the user provide either the "-{}-master" flag, which indicates that the process should run as the master node of a daemon, or "-{}-worker <IP of master node>", which indicates that hmmpgmd should run as a worker node with its master node at the specified IP address\sidenote{If the master node's IP is omitted, hmmpgmd defaults to connecting to a master process on the same node it is running on.}.  Note that this IP address must be provided as a numeric value, for example "127.0.0.1", and not as a text machine name, as hmmpgmd does not perform domain name service lookup on the provided IP address.  

When run as a master node, hmmpgmd requires that the user provide at least one of the "-{}-seqdb <filename>", or "-{}-hmmdb <filename>" options to specify a sequence and/or HMM database for the daemon to cache in RAM.  The user may specify both a sequence and an HMM database file that the daemon should cache.  The master node reads the database(s) itself and also sends the specified filename(s) to each of the worker nodes so that they can cache their own copies of the database(s).  Thus, the database file(s) must be available on all of the nodes in the daemon and the filename(s) provided must be valid paths to the database file(s) on all of the nodes, either because hmmpgmd is invoked from the same directory on every node or because the filename(s) are specified as full paths from the root node of the filesystem.

When run as a master node, hmmpgmd first reads its input databases and then listens for socket connections from worker nodes.  When a worker node connects to the master, the master outputs {\tt "Handling worker <IP address> (socket number)"} to its display or logfile.  After the worker has read its databases and is ready to handle work, the master outputs {\tt "Pending worker <IP address> (socket number)"}.  The master can begin accepting search requests from clients as soon as one worker node has reached the pending state, and will distribute each search across all of the worker nodes that are pending when the search begins.


\subsection{Running Hmmpgmd\_shard}
Starting a daemon that shards its sequence database(s) using the hmmpgmd\_shard program follows the same procedure as starting an undsharded daemon, with two exceptions.  First, when run on the master node hmmpgmd\_shard takes a mandatory "--num\_shards <n>" argument, which specifies the number of shards that the sequence database file should be broken into.  This must be equal to the number of worker nodes that will connect to the master.  Second, because each worker node only contains a portion of its sequence database(s), hmmpgmd\_shard can only process search requests when the number of worker nodes connected to it is equal to the number of shards.  Attempting to run searches before that many worker nodes have connected will return an error.  Attempting to connect more worker nodes than the specified number of shards causes the daemon to exit.

Note that hmmpgmd\_shard only shards sequence databases.  HMM databases are not sharded, due to their small size, so there is no reason to use hmmpgmd\_shard on HMM databases. 


\section{Sending Searches to a Daemon}
The HMMER package includes {\em hmmc2}, an example client that can communicate with an hmmpgmd or hmmpgmd\_shard daemon.  Hmmc2 accepts four command-line arguments\sidenote{The code in hmmc2.c breaks HMMER convention by defining an Easel options structure, {searchOpts}, which specifies options that can be passed to a search request within the interactive loop that hmmc2 starts.  The actual arguments to the hmmc2 program are parsed by custom code in hmmc2.c that does not call the Easel argument parser.}:

\begin{itemize}
  \item{\underline{-i <IP address>}: specifies the IP address of the daemon to connect to.  Defaults to 127.0.0.1 if not provided.}
  \item{\underline{-p <port>}: specifies the port number that the daemon is listening to for client connections.  Defaults to 51371 (the hmmpgmd default) if not provided.}
  \item{\underline{-S}: print the scores of any hits found by searches}
  \item{\underline{-A}: print the alignments of any hits found by searches.  The data printed when this option is provided is a superset of the data printed when "-S" is provided, so the "-S" option is redundant if -A is provided.}
\end{itemize}

Once it starts up, hmmc2 enters an interactive loop by printing the prompt "Enter next sequence:".  Any text the user enters between that prompt and the end-of-command string "{\tt //}" is interpreted as a command and sent to the daemon.  Thus, using hmmc2 to perform a phmmer-style search of a short protein sequence against a small protein database might produce the following output:

 \vspace{-1ex}
  \xsreoutput{inclusions/hmmc2.out}
 \vspace{-1ex}

Here, the text
  \vspace{1ex}
  \user{@--seqdb 1}
  \user{>sp|Q6GZW9|length\_10}
  \user{YLGPWVQAEY}
  \user{//}
  \vspace{1ex}
is the command the user entered into the interactive loop, and the rest of the text is the output generated by hmmc2.  In this example, hmmc2 was invoked without the "-S" or "-A" options, so only prints statistics about the number of comparisons that passed each stage in HMMER's pipelines and the number of hits found.  Hmmc2 remains in its interactive loop until killed with control-c or some other command.

\chapter{Daemon-Client Interface}
Client machines use internet sockets to send commands to and receive results from a daemon's master node.  When a client opens a connection to the master node's client communication port (port 51371 by default), the master node forks a thread to manage the connection with the client.  This thread configures a socket to communicate with the client and then repeatedly calls the {\tt clientside\_loop} function, which monitors the socket for commands from the client, until either the client detaches from the port or the daemon shuts down.  This approach allows multiple clients to connect to a daemon simultaneously without interfering with each other, although requests from one client may impact the amount of time it takes for the daemon to respond to requests from other clients.


\section{Daemon Command Format}
Daemon commands are variable-length sequences of ASCII text.  The first line of a command must contain the command itself and any options or parameters.  For search commands, this is followed by one or more lines that contain the sequence or HMM to be searched.  All commands end with a line that contains only two forward slashes ("{\tt //}").  When a command arrives from a client, the daemon reads bytes from the appropriate socket into a buffer until it sees the end-of-command sequence, growing the buffer as necessary\sidenote{This is a security vulnerability that should be addressed in HMMER4, as it allows an adversarial or erroneous client to consume arbitrary amounts of RAM, potentially exceeding the capacity of the master node.}, and then parses the contents of the buffer in order to execute the command.   

The daemon supports three commands:

\begin{itemize}
  \item{\underline{@-{}-hmmdb <database \#>}:  Initiates a search of a protein sequence against the HMM database cached by the daemon.  The protein sequence to be searched must be provided on the lines following the @-{}-hmmdb command.  Note that there is a discrepancy between this command format and hmmpgmd's capabilities.  The command requires that the user specify a database number, but hmmpgmd cannot cache multiple HMM databases in RAM simultaneously.  Changing the database number provided has no effect -- the daemon performs a search against the one database it has cached.}
  \item{\underline{@-{}-seqdb <database \#> [-{}-seqdb\_ranges <rangelist>]}: Initiates a search of a protein sequence or HMM against the specified protein sequence database\sidenote{Note that there is an inconsistency in how databases are numbered in search commands as compared to how they are numbered in the database file itself.  The database file uses 0-indexed numbering, (databases are numbered from 0 to N-1), while the search commands use 1-indexed numbering (databases are numbered from 1 to N)}.  The daemon determines whether a sequence or HMM has been submitted by examining the contents of the lines that follow the command, and, if a sequence has been submitted, converts it to an HMM before performing the search.

  If the -{}-seqdb\_ranges option is not provided, the entire target database is searched\sidenote{Currently, there is no way to search only a portion of an HMM database.  This is probably because existing HMM databases are small enough that the time to search them is rarely an issue.}. If the -{}-seqdb\_rangelist option is provided, it must be followed by a rangelist describing the set of sequences to be searched.  Each range in the rangelist should be formatted in the form "start..end", where "start" and "end" are the sequence IDs of the start and end of the range, and ranges in the list should be separated by commas. One note here is that the sequences in a sequence file are indexed as a single contiguous list, even if the file contains multiple databases, and each database can contain an arbitrary subset of the sequences in the file.  Thus, the sequence IDs specified in a rangelist refer to positions within the database file, and a rangelist search searches the sequences in the specified database whose IDs fall into the specified range(s), not the specified positions in the set of sequences contained in the database. Example: the command @-{}-seqdb 2 -{}-seqdb\_ranges 1..100, 201..300 searches the sequences in database 2 whose sequence ID's range from 1 to 100 or 201 to 300, not sequences 1-100 and 201-300 of the database.}
  \item{\underline{!shutdown}: Shuts the daemon down in an orderly fashion by first sending shutdown messages to all of its worker nodes and then exiting the master node's processes\sidenote{There's another security vulnerability here, in that any machine that can connect to the master node can shut it down.  This needs to be addressed in H4, as we intend to allow arbitrary clients to send searches to a server}.}
\end{itemize}

When the daemon receives a search command, any text on the command line after the "@-{}-seqdb <database \#>" or "@-{}-hmmdb <database \#>" specifies options to the search, using the same format as the hmmsearch or hmmscan commands.  Thus sending the command "@-{}-seqdb 1 -E 20" to the daemon instructs it to perform a search of sequence database 1, reporting all results with an e-value of less than 20 instead of the default 10.

Hmmpgmd does not handle user errors when specifying the database to search well.  Attempting to search an HMM or sequence database when no such database has been loaded causes the daemon to crash.  Attempting to search a non-existent sequence database, such as searching database 100 when only one database is loaded, is treated as a search of a zero-length database.  Specifying a search of an HMM database other than database 1 is ignored, and the daemon searches database 1.

\section{Search Results Format}
The results from each search are split across two sockets messages, as shown in Figure \ref{fig:search-results}.  The first is a fixed-length {\tt HMMD\_SEARCH\_STATUS} structure that contains two fields: a {\em status} field that contains an Easel status code that tells the client whether the search completed successfully or not, and a {\em msg\_size} field, which tells the client how large (in bytes) the second message will be.  The format of the second message depends on whether any errors were encountered during the search.  If an error occured, the second message is simply a text string containing a description of the error.  


\begin{figure*}
\includegraphics[width=\textwidth]{inclusions/daemon-results.pdf}
\caption{Format of the Messages the Daemon Sends to a Client When a Search Completes}
\label{fig:search-results}
\end{figure*}

If the search succeeded, the {\tt status} field of the first message is set to "eslOK" and the second message contains the results of the search.  This message begins with a {HMMD\_SEARCH\_STATS} structure that contains information about the search, including the time the search took and the number of hits found.  This is then followed by a {P7\_HIT} structure for each hit the search found, which describes the hit.

\section{Serialization}
Data structures and multi-byte values must be {\em serialized} before they can be sent over sockets.  There are two aspects to serializing the types of data structures the daemon uses.  Structures that contain pointers must be {\em flattened} by copying the data that their pointers point to into the block of data that will be sent over the socket, and multi-byte values must be converted to "network order," which is defined as big-endian, to prevent problems if the sending and receiving machines have different endiannesses.  To serialize floating-point numbers, we assume that all computers use IEEE 754 representations and just convert the bytes that represent the floating-point number two and from network byte order.  This is faster than the alternative approach of representing the floating-point number as an ASCII string and parsing it on the receiving side, and avoids any loss of precision, but will fail if HMMER is compiled on a machine that uses a different floating-point format.  

Figures \ref{fig:search-stats-serialize}-\ref{fig:alidisplay-serialize} show how the data structures used in sending search results back to clients are serialized.  The text streams the client uses to send commands to the daemon do not require serialization, as text streams do not contain pointers and are sequences of byte-wide characters that are not affected by endianness.  The {HMMD\_SEARCH\_STATS} structure, shown in Figure \ref{fig:search-stats-serialize}, does not contain any pointers, so can be serialized by simply converting each field in the structure to network byte order before sending and reversing the conversion on the receiving side.  

\begin{figure*}
\includegraphics[width=\textwidth]{inclusions/hmmpgmd-search-stats-serialize.pdf}
\caption{Serialized {HMMD\_SEARCH\_STATS} Structure}
\label{fig:search-stats-serialize}
\end{figure*} 

\begin{figure*}
\includegraphics[width=\textwidth]{inclusions/hit-serialize.pdf}
\caption{Serialized {P7\_HIT} Structures}
\label{fig:hit-serialize}
\end{figure*}
\begin{figure*}
\includegraphics[width=\textwidth]{inclusions/domain-serialize.pdf}
\caption{Serialized {P7\_DOMAIN} Structure}
\label{fig:domain-serialize}
\end{figure*}
\begin{figure*}
\includegraphics[width=\textwidth]{inclusions/alidisplay-serialize.pdf}
\caption{Serialized {P7\_ALIDISPLAY} Structure}
\label{fig:alidisplay-serialize}
\end{figure*}

The {P7\_HIT}, {P7\_DOMAIN}, and {P7\_ALIDISPLAY} structures contain strings and/or pointers to other data structures, and are serialized using the following format.  The serialized representation begins with a four-byte {\em size} field that contains the size (in bytes) of the serialized data structure, not including any data structures that it originally pointed to\sidenote{}.  Fields in the data structure are serialized in the same order they appear in the structure, with the exception of pointers to other data structures.  String fields are replaced by a size field that encodes the size of the string in bytes, including the termination character, and the contents of any strings are placed after the data structure's fixed-width fields, in the order that they appear in the data structure.  Any structures that the data structure contains pointers to are recursively serialized after any string fields, again in the order that they appear in the data structure.

Some of the string fields in these data structures are optional, and may have a value of NULL.  NULL strings are serialized by placing a "0" in the corresponding string length field of the serialized data structure.  Length-0 strings (strings that contain only the end-of-string character) will have a value of "1" in the corresponding string length field, because the value of the string length field includes the byte for the end-of-string character, making it possible to distinguish an omitted string field from one that contains a length-0 string.

The {P7\_ALIDISPLAY} structure is a slight exception to the serialization format, because many of its string fields are required to be the same length as the alignment the structure represents, which is encoded in the structure's {\tt N} field.  To save space, we omit the length fields for these strings and treat them all as being {\tt N}+1 bytes long to account for the termination character at the end of each string.

Functions to serialize and deserialize each of the daemon's data structures are provided in the .c files that contain the structure's routines.     

\chapter{Database File Formats}
The formats hmmpgmd uses for HMM and sequence databases are derived from the formats used elsewhere in HMMER, with modifications to support integration with EBI's infrastructure and reduce the size of sequence databases.

\section{HMM Database File Format}
Hmmpgmd uses the HMMER 3 profile HMM file format as described in the \underline{HMMER User's Guide} for its HMM databases, with the requirement that the HMM file must have been processed by hmmpress before it can be loaded into hmmpgmd.  When an HMM database is cached in RAM, it is represented as a simple array of P7\_OPROFILE objects, although each HMM's name is replaced with its ID number (position in the database file).  Each HMM file can only contain a single HMM database, and hmmpgmd does not support caching of multiple HMM databases simultaneously.

\section{Sequence Database File Format}
The \mono{hmmpgmd} format that hmmpgmd uses for sequence database files is a variant of the FASTA format in which each sequence's description contains a number of fields that allow a single file to contain multiple databases efficiently.  A FASTA file can be converted into a single-database hmmpgmd sequence file using the \mono{esl-reformat} command.  For example, 

\user{esl-reformat --id\_map mydb.hmmpgmd.map hmmpgmd mydb.fasta > mydb.hmmpgmd}

generates the \mono{hmmpgmd} file "mydb.hmmpgmd\sidenote{The ".hmmpgmd" extension used here is only a convention.  Hmmpgmd does not enforce any restrictions on the names of its input files.}" from the FASTA file "mydb.fasta", using the optional \mono{--id\_map} flag to specify that the mapping between the sequence names and descriptions found in the FASTA file to the sequence ID numbers used in the hmmpgmd file should be written to "mydb.hmmpgmd.map".  HMMER does not provide a tool to generate sequence files that contain multiple databases.  The EBI uses a tool flow of their own development to generate the multi-database files that they use in their HMMER server.

The are two main differences between an \mono{hmmpgmd} file and a FASTA file.  First, a \mono{hmmpgmd} file replaces each sequence's name and description information with a numeric ID, which is just the position of the sequence in the file.  This reduces the amount of memory required to cache databases, but requires that the client recover the name and description of each sequence that the daemon returns as a hit in order to generate human-readable output.  Second, it adds a bit-vector to each sequence's description that identifies the set of databases that contain the sequence, to avoid having to cache multiple copies of a sequence in RAM.  

An \mono{hmmpgmd} file begins with a header line that contains information about the file's contents, which takes the form 

\monob{\#res\_cnt seq\_cnt db\_cnt cnt\_1 fullcnt\_1 cnt\_2 fullcnt\_2 $\ldots$ date\_stamp}.

The "\#" character at the start of the header line is mandatory, and allows HMMER/Easel's file parsing code to recognize the file as an \mono{hmmpgmd} file instead of a standard FASTA file.  The fields in the header line have the following meanings:

\begin{sreitems}{\monob{header}}

\item [\monob{res\_cnt}] Number of residues in the sequence file.

\item [\monob{seq\_cnt}] Number of sequences in the sequence file. 

\item [\monob{db\_cnt}] Number of databases in the sequence file. 

\item [\monob{cnt\_i}] The number of sequences in database \mono{i}. This will always be less than or equal to \mono{seq\_cnt}.
 
\item [\monob{fullcnt\_i}] The number of sequences that should be used when computing E-values for database \mono{i}.  This will always be at least as large as \mono{cnt\_i}, and may be larger if database \mono{i} contained redundant sequences that were collapsed out.

\end{sreitems}

After the header line, the file must contain \monob{seq\_cnt} sequence entries, which use a FASTA-like fomat where the first line of each sequence entry takes the form 

\monob{>seq\_id database\_membership domain\_architecture taxonomy\_id}

and the second and following lines contain the amino-acid specification of the sequence\sidenote{Hmmpgmd only supports caching of amino-acid sequences due to the large size of nucleotide sequence databases.}  

The fields in a sequence's first line have the following meanings:

\begin{sreitems}{\monob{header}}

\item [\monob{seq\_id}] The sequence's ID number, which must be its position in the file, where the first sequence in the file has ID 1. This requirement exists because hmmpgmd generates a string encoding of each sequence's ID by incrementing an internal counter for each sequence and stores that string encoding in the sequence structure's \mono{name} field.  Thus, the sequence ID hmmpgmd caches will be the sequence's position in the database file regardless of the value of \mono{seq\_id}.  Note that the IDs used by hmmpgmd are absolute and refer to each sequence's position in the original data file, not its position in a particular database.

\item [\monob{database\_membership}] This field is a bit-vector that encodes the set of databases that contain the sequence, where a "1" indicates that the sequence is present in the corresponding database and a "0" indicates that it is not present.  Databases are represented ascending order from left to right in the string, so the leftmost position in the string determines whether the sequence is present in database 1, the next position determines whether the string is present in database 2, and so on.  By convention, this field always contains as many digits as there are databases in the file, but the only absolute requirement is that it not contain more digits than there are databases in the file.

\item [\monob{domain\_architecture}] If provided, this optional field must contain the string representation of an integer that can be represented as a long int.  When hmmpgmd finds a hit, it converts this field into a long integer and stores it in the \mono{desc} field of the hit's \mono{{P7\_HIT}} structure, which is then returned to the client\sidenote{This is a nasty hack that we should avoid in the future if at all possible.}.  EBI uses this field to encode the ID of a database entry that describes the sequence's domain architecture and is used to improve the display of results on their web clients.   

\item [\monob{taxonomy\_id}] If provided, this optional field must contain the string representation of an integer that can be represented as a long int.  When a hit occurs, hmmpgmd returns it in the \mono{acc} field of the hit's \mono{{P7\_HIT}} structure.  EBI uses this field to encode the ID of a database entry that describes the sequence's taxonomy for use by their web clients.

\end{sreitems}

As an example, consider the following set of sequence entries:

\begin{sreoutput}
>1 100
ACDEFGHIKLMNPQTVWY
>2 010
ACDKLMNPQTVWYEFGHI
>3 111
EFMNRGHIKLMNPQT
\end{sreoutput}

Sequence 1 in the set is part of database 1.  Sequence 2 is part of database 2, while sequence 3 is part of databases 1, 2, and 3.  This set of entries omits the optional \mono{domain\_architecture} and \mono{taxonomy\_id} fields from each sequence.




\begin{adjustwidth}{}{-1in}   
\chapter{Manual Pages Related to the Daemon}
\input{manpages_daemon}
\end{adjustwidth}

\chapter{Acknowledgments}
We would like to thank all of the organizations that have supported the development of HMMER, as well as all of the individuals who have contributed to it. In particular, Washington University, the National Institutes of Health, Monsanto, the Howard Hughes Medical Institute, and Harvard University have been major supporters of this work.  For a more thorough set of acknowledgments that includes a discussion of HMMER's history, please see the \underline{HMMER User's Guide}.

\label{manualend}

% To create distributable/gitted 'distilled.bib' from lab's bibtex dbs:
%   # uncomment the {master,lab,books}
%   pdflatex main
%   bibdistill main.aux > distilled.bib
%   # restore the {distilled} 
% 
\nobibliography{distilled}
%\nobibliography{master,lab,books}

\end{document}



